//*******************************  Библиотеки  ******************************//
#include <Arduino.h>

#include "Timer.h"

#include "FastIO.h"

#include "UARTDebug.h"
//*******************************  /Библиотеки  *****************************//

/// <summary>
/// Переменная хранящее максимальное значение unsigned long
/// </summary>
#define unsignedLongMax 4294967295UL

/// <summary>
/// Переменная хранящее 1, для проверки скорости выполнения цикла
/// </summary>
#define digitalOne 1UL

//********* Функции работы с таймерами на основе millis(), micros() *********//
/// <summary>
/// Проверка таймера на основе millis
/// </summary>
uint8_t CheckTimerMillis(uint32_t PreviousTimmer, uint32_t Time)
{
  // Если предыдущие значение, больше 0
  if (PreviousTimmer)
  {
    // Получаем время с момента запуска программы и отнимем значение PreviousTimmer (время с начала запуска таймера). После это проверяем, прошло ли установленное время Time  
    if (GetDifferenceULong(PreviousTimmer, millis()) >= Time)
    {
      // Возвращаем true
      return 1;
    }
  }

  return 0;
}

/// <summary>
/// Получение разницы между 2 uint32_t
/// </summary>
uint32_t GetDifferenceULong(uint32_t BeginTime, uint32_t EndTime)
{
  if (EndTime < BeginTime)
  {
    // Защита от переполнения
    return unsignedLongMax - BeginTime + EndTime + digitalOne;
  }
  else
  {
    return EndTime - BeginTime;
  }
}
//********* /Функции работы с таймерами на основе millis(), micros() ********//

//**************** Функции работы с таймерами для Servo и ESC ***************//
// 4-верть сигнала в 50Hz, импульсы идут одие за другим.
#define SERVO_CYCLE 10000U

// Угол поворота сервы (1 тик таймера 0,004ms, нетральное положение 0,6ms).
// 1 серва.
volatile uint16_t servoAngle1 = 1200;
// 2 серва.
volatile uint16_t servoAngle2 = 2400;
// 3 серва.
volatile uint16_t servoAngle3 = 3600;
// 4 серва.
volatile uint16_t servoAngle4 = 4800;
// Переменная номер шага для прерывния TIMER1_COMPA_vect.
volatile uint8_t servoTakt = 0;

void SetupTimer1ForServo()
{
  MC_SET_PIN_OUTPUT(46);
    
  MC_SET_PIN_OUTPUT(47);
  
  MC_SET_PIN_OUTPUT(48);

  MC_SET_PIN_OUTPUT(49);
  
  // TCCR1A - регистр управления A.
  TCCR1A = 0;

  // TCCR1B - регистр управления B.
  TCCR1B = 0;

  // TCCR1A - регистр управления A.
  // TCCR1B - регистр управления B.
  // Биты WGM13 (4) , WGM12 (3) регистра TCCR1B и биты WGM11 (1) , WGM10 (0) регистра TCCR1A устанавливают режим работы таймера/счетчика T1:
  // 0000 - обычный режим
  // 0001 - коррекция фазы PWM, 8-бит
  // 0010 - коррекция фазы PWM, 9-бит
  // 0011 - коррекция фазы PWM, 10-бит
  // 0100 - режим счета импульсов (OCR1A) (сброс при совпадении)
  // 0101 - PWM, 8-бит
  // 0110 - PWM, 9-бит
  // 0111 - PWM, 10-бит
  // 1000 - коррекция фазы и частоты PWM (ICR1)
  // 1001 - коррекция фазы и частоты PWM (OCR1A)
  // 1010 - коррекция фазы PWM (ICR1)
  // 1011 - коррекция фазы и частоты PWM (OCR1A)
  // 1100 - режим счета импульсов (ICR1) (сброс при совпадении)
  // 1101 - резерв
  // 1110 - PWM (ICR1)
  // 1111 - PWM (OCR1A)

  // 0100 - режим счета импульсов (OCR1A) (сброс при совпадении)
  TCCR1A |= (0 << WGM11) | (0 << WGM10);
  TCCR1B |= (1 << WGM12) | (0 << WGM13);

  // TCCR1A - регистр управления A.
  // Биты COM1A1 (7) и COM1A0 (6) влияют на то, какой сигнал появится на выводе OC1A (15 ножка) при совпадении с A (совпадение значения счетного регистра TCNT1 со значением регистра сравнения OCR1A):
  /* 1. Обычный режим
  00 - вывод OC1A не функционирует
  01 - изменение состояния вывода OC1A на противоположное при совпадении с A
  10 - сброс вывода OC1A в 0 при совпадении с A
  11 - установка вывода OC1A в 1 при совпадении с A
      2. Режим ШИМ
  00 - вывод OC1A не функционирует
  01 - если биты WGM13 - WGM10 установлены в (0000 - 1101), вывод OC1A не функционирует
  01 - если биты WGM13 - WGM10 установлены в 1110 или 1111, изменение состояния вывода OC0A на противоположное при совпадении с A
  10 - сброс вывода OC1A в 0 при совпадении с A, установка  вывода OC1A в 1 если регистр TCNT1 принимает значение 0x00 (неинверсный режим)
  11 - установка вывода OC1A в 1 при совпадении с A, установка  вывода OC1A в 0 если регистр TCNT1 принимает значение 0x00  (инверсный режим)
      3. Режим коррекции фазы ШИМ
  00 - вывод OC1A не функционирует
  01 - если биты WGM13 - WGM10 установлены в (0000 - 1100, 1010, 1100 - 1111), вывод OC1A не функционирует
  01 - если биты WGM13 - WGM10 установлены в 1101 или 1011, изменение состояния вывода OC1A на противоположное при совпадении с A
  10 - сброс вывода OC1A в 0 при совпадении с A во время увеличения значения счетчика, установка  вывода OC1A в 1  при совпадении с A во время уменьшения значения счетчика
  11 - установка вывода OC1A в 1 при совпадении с A во время увеличения значения счетчика, сброс  вывода OC1A в 0  при совпадении с A во время уменьшения значения счетчика
  */
  TCCR1A |= (0 << COM1A1) | (0 << COM1A0);

  // Разрешают прерывания при совпадении с A.
  TIMSK1 |= (1 << OCIE1A);

  // TCCR1B - регистр управления B.
  // Биты CS12 (2), CS11 (1), CS10 (0) регистра TCCR1B устанавливают режим тактирования и предделителя тактовой частоты таймера/счетчика T1:
  // 000 - таймер/счетчик T1 остановлен
  // 001 - тактовый генератор CLK
  // 010 - CLK/8
  // 011 - CLK/64
  // 100 - CLK/256
  // 101 - CLK/1024
  // 110 - внешний источник на выводе T1 (11 ножка) по спаду сигнала
  // 111 - внешний источник на выводе T1 (11 ножка) по возрастанию сигнала
  // 011 - CLK/64
  TCCR1B |= (0 << CS12) | (1 << CS11) | (0 << CS10); 
}

// Прерывание при совпадении с регистром OCR1A.
ISR(TIMER1_COMPA_vect) 
{
  // Шаг 0.
  if (servoTakt == 0) 
  {
    PORTL |= (1 << 3);
    //MC_WRITE_PIN(46, 1);
    OCR1A = servoAngle1;
  }
  // Шаг 1.
  if (servoTakt == 1) 
  {
    PORTL &= ~(1 << 3);
    OCR1A = SERVO_CYCLE - servoAngle1;
  }
  // Шаг 2.
  if (servoTakt == 2) 
  {
    PORTL |= (1 << 2);
    OCR1A = servoAngle2;
  }
  // Шаг 3.
  if (servoTakt == 3) 
  {
    PORTL &= ~(1 << 2);
    OCR1A = SERVO_CYCLE - servoAngle2;
  }
  // Шаг 4.
  if (servoTakt == 4) 
  {
    PORTL |= (1 << 1);
    OCR1A = servoAngle3;
  }
  // Шаг 5.
  if (servoTakt == 5) 
  {
    PORTL &= ~(1 << 1);
    OCR1A = SERVO_CYCLE - servoAngle3;
  }
  // Шаг 6.
  if (servoTakt == 6) 
  {
    PORTL |= (1 << 0);
    OCR1A = servoAngle4;
  }
  // Шаг 7.
  if (servoTakt == 7) 
  {
    PORTL |= (1 << 0);
    OCR1A = SERVO_CYCLE - servoAngle4;
  }

  // Увеличиваем шаг.
  servoTakt++;

  // Обнуляем шаг.
  if (servoTakt == 8) 
  {
    servoTakt = 0;
  }
};

void SetupTimer3ForESC()
{
  MC_SET_PIN_OUTPUT(2);
    
  MC_SET_PIN_OUTPUT(3);
  
  MC_SET_PIN_OUTPUT(5);
  
  // TCCR3A - регистр управления A.
  TCCR3A = 0;

  // TCCR3B - регистр управления B.
  TCCR3B = 0;

  // TCCR3C - регистр управления С.
  TCCR3C = 0;

  // TCCR3A - регистр управления A.
  // TCCR3B - регистр управления B.

  
  // Биты WGM33 (4) , WGM32 (3) регистра TCCR3B и биты WGM31 (1), WGM30 (0) регистра TCCR3A устанавливают режим работы таймера/счетчика T3:
  // 0000 - обычный режим
  // 0001 - коррекция фазы PWM, 8-бит
  // 0010 - коррекция фазы PWM, 9-бит
  // 0011 - коррекция фазы PWM, 10-бит
  // 0100 - CTC режим счета импульсов (OCR3A) (сброс при совпадении)
  // 0101 - Fast PWM, 8-бит
  // 0110 - Fast PWM, 9-бит
  // 0111 - Fast PWM, 10-бит
  // 1000 - коррекция фазы и частоты PWM (ICR3)
  // 1001 - коррекция фазы и частоты PWM (OCR3A)
  // 1010 - коррекция фазы PWM (ICR3)
  // 1011 - коррекция фазы PWM (OCR3A)
  // 1100 - CTC режим счета импульсов (ICR3) (сброс при совпадении)
  // 1101 - резерв
  // 1110 - Fast PWM (ICR3)
  // 1111 - Fast PWM (OCR3A)

  // 1110 - PWM (ICR3)
  TCCR3A |= (1 << WGM31) | (0 << WGM30);
  TCCR3B |= (1 << WGM32) | (1 << WGM33);

  // ICR3 - регистр захвата (16 бит)
  ICR3 = 6000; // 6000 - 333,3Hz // 6665 - 300Hz // 8000 - 250Hz // 10000 - 200Hz // 12500 - 160Hz // 20000 - 100Hz // 40000 - 50Hz

  // OCR3A - регистр сравнения A (16 бит)
  OCR3A = 1200;

  // OCR3B - регистр сравнения B (16 бит)
  OCR3B = 1200;

  // OCR3C - регистр сравнения C (16 бит)
  OCR3C = 1200;

  // TCCR3A - регистр управления A.
  // Биты COM3A1 (7) и COM3A0 (6) влияют на то, какой сигнал появится на выводе OC3A (15 ножка) при совпадении с A (совпадение значения счетного регистра TCNT3 со значением регистра сравнения OCR3A):
  /* 1. Обычный режим
  00 - вывод OC3A не функционирует
  01 - изменение состояния вывода OC3A на противоположное при совпадении с A
  10 - сброс вывода OC3A в 0 при совпадении с A
  11 - установка вывода OC3A в 1 при совпадении с A
      2. Режим ШИМ
  00 - вывод OC1A не функционирует
  01 - если биты WGM33 - WGM30 установлены в (0000 - 1101), вывод OC3A не функционирует
  01 - если биты WGM33 - WGM30 установлены в 1110 или 1111, изменение состояния вывода OC3A на противоположное при совпадении с A
  10 - сброс вывода OC3A в 0 при совпадении с A, установка  вывода OC3A в 1 если регистр TCNT3 принимает значение 0x00 (неинверсный режим)
  11 - установка вывода OC3A в 1 при совпадении с A, установка  вывода OC3A в 0 если регистр TCNT3 принимает значение 0x00  (инверсный режим)
      3. Режим коррекции фазы ШИМ
  00 - вывод OC3A не функционирует
  01 - если биты WGM33 - WGM30 установлены в (0000 - 1100, 1010, 1100 - 1111), вывод OC3A не функционирует
  01 - если биты WGM33 - WGM30 установлены в 1101 или 1011, изменение состояния вывода OC3A на противоположное при совпадении с A
  10 - сброс вывода OC3A в 0 при совпадении с A во время увеличения значения счетчика, установка  вывода OC3A в 1  при совпадении с A во время уменьшения значения счетчика
  11 - установка вывода OC3A в 1 при совпадении с A во время увеличения значения счетчика, сброс  вывода OC3A в 0  при совпадении с A во время уменьшения значения счетчика
  */
  TCCR3A |= (1 << COM3A1) | (0 << COM3A0) | (1 << COM3B1) | (0 << COM3B0) | (1 << COM3C1) | (0 << COM3C0);

  // TCCR3B - регистр управления B.
  // Биты CS32 (2), CS31 (1), CS30 (0) регистра TCCR3B устанавливают режим тактирования и предделителя тактовой частоты таймера/счетчика T3:
  // 000 - таймер/счетчик T3 остановлен
  // 001 - тактовый генератор CLK
  // 010 - CLK/8
  // 011 - CLK/64
  // 100 - CLK/256
  // 101 - CLK/1024
  // 110 - внешний источник на выводе T3 (11 ножка) по спаду сигнала
  // 111 - внешний источник на выводе T3 (11 ножка) по возрастанию сигнала
  // 011 - CLK/64
  TCCR3B |= (0 << CS32) | (1 << CS31) | (0 << CS30);
}

void SetupTimer4ForESC()
{
  MC_SET_PIN_OUTPUT(6);
    
  MC_SET_PIN_OUTPUT(7);
  
  MC_SET_PIN_OUTPUT(8);
  
  // TCCR4A - регистр управления A.
  TCCR4A = 0;

  // TCCR4B - регистр управления B.
  TCCR4B = 0;

  // TCCR4C - регистр управления С.
  TCCR4C = 0;

  // TCCR4A - регистр управления A.
  // TCCR4B - регистр управления B.

  
  // Биты WGM43 (4) , WGM42 (3) регистра TCCR4B и биты WGM41 (1), WGM40 (0) регистра TCCR4A устанавливают режим работы таймера/счетчика T4:
  // 0000 - обычный режим
  // 0001 - коррекция фазы PWM, 8-бит
  // 0010 - коррекция фазы PWM, 9-бит
  // 0011 - коррекция фазы PWM, 10-бит
  // 0100 - CTC режим счета импульсов (OCR4A) (сброс при совпадении)
  // 0101 - Fast PWM, 8-бит
  // 0110 - Fast PWM, 9-бит
  // 0111 - Fast PWM, 10-бит
  // 1000 - коррекция фазы и частоты PWM (ICR4)
  // 1001 - коррекция фазы и частоты PWM (OCR4A)
  // 1010 - коррекция фазы PWM (ICR4)
  // 1011 - коррекция фазы PWM (OCR4A)
  // 1100 - CTC режим счета импульсов (ICR4) (сброс при совпадении)
  // 1101 - резерв
  // 1110 - Fast PWM (ICR4)
  // 1111 - Fast PWM (OCR4A)

  // 1110 - PWM (ICR4)
  TCCR4A |= (1 << WGM41) | (0 << WGM40);
  TCCR4B |= (1 << WGM42) | (1 << WGM43);

  // ICR3 - регистр захвата (16 бит)
  ICR4 = 6000; // 6000 - 333,3Hz // 6665 - 300Hz // 8000 - 250Hz // 10000 - 200Hz // 12500 - 160Hz // 20000 - 100Hz // 40000 - 50Hz

  // OCR4A - регистр сравнения A (16 бит)
  OCR4A = 1200;

  // OCR4B - регистр сравнения B (16 бит)
  OCR4B = 1200;

  // OCR4C - регистр сравнения C (16 бит)
  OCR4C = 1200;

  // TCCR4A - регистр управления A.
  // Биты COM4A1 (7) и COM4A0 (6) влияют на то, какой сигнал появится на выводе OC4A (15 ножка) при совпадении с A (совпадение значения счетного регистра TCNT4 со значением регистра сравнения OCR4A):
  /* 1. Обычный режим
  00 - вывод OC4A не функционирует
  01 - изменение состояния вывода OC4A на противоположное при совпадении с A
  10 - сброс вывода OC4A в 0 при совпадении с A
  11 - установка вывода OC4A в 1 при совпадении с A
      2. Режим ШИМ
  00 - вывод OC4A не функционирует
  01 - если биты WGM43 - WGM40 установлены в (0000 - 1101), вывод OC4A не функционирует
  01 - если биты WGM43 - WGM40 установлены в 1110 или 1111, изменение состояния вывода OC4A на противоположное при совпадении с A
  10 - сброс вывода OC4A в 0 при совпадении с A, установка  вывода OC4A в 1 если регистр TCNT4 принимает значение 0x00 (неинверсный режим)
  11 - установка вывода OC4A в 1 при совпадении с A, установка  вывода OC4A в 0 если регистр TCNT4 принимает значение 0x00  (инверсный режим)
      3. Режим коррекции фазы ШИМ
  00 - вывод OC4A не функционирует
  01 - если биты WGM43 - WGM40 установлены в (0000 - 1100, 1010, 1100 - 1111), вывод OC4A не функционирует
  01 - если биты WGM43 - WGM40 установлены в 1101 или 1011, изменение состояния вывода OC4A на противоположное при совпадении с A
  10 - сброс вывода OC4A в 0 при совпадении с A во время увеличения значения счетчика, установка  вывода OC4A в 1  при совпадении с A во время уменьшения значения счетчика
  11 - установка вывода OC4A в 1 при совпадении с A во время увеличения значения счетчика, сброс  вывода OC4A в 0  при совпадении с A во время уменьшения значения счетчика
  */
  TCCR4A |= (1 << COM4A1) | (0 << COM4A0) | (1 << COM4B1) | (0 << COM4B0) | (1 << COM4C1) | (0 << COM4C0);

  // TCCR4B - регистр управления B.
  // Биты CS42 (2), CS41 (1), CS40 (0) регистра TCCR4B устанавливают режим тактирования и предделителя тактовой частоты таймера/счетчика T4:
  // 000 - таймер/счетчик T4 остановлен
  // 001 - тактовый генератор CLK
  // 010 - CLK/8
  // 011 - CLK/64
  // 100 - CLK/256
  // 101 - CLK/1024
  // 110 - внешний источник на выводе T4 (11 ножка) по спаду сигнала
  // 111 - внешний источник на выводе T4 (11 ножка) по возрастанию сигнала
  // 011 - CLK/64
  TCCR4B |= (0 << CS42) | (1 << CS41) | (0 << CS40);
}
//*************** /Функции работы с таймерами для Servo и ESC ***************//
